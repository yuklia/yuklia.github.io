[{"content":"Traefik v1.7 is running within a Docker Swarm, functioning as a global service. Consequently, an instance of Traefik is deployed for each host within our Docker Swarm cluster. It is important to note that the Swarm\u0026rsquo;s routing mesh is not employed in this setup. Instead, the port mode is configured as \u0026ldquo;host,\u0026rdquo; allowing the port to be attached to the host\u0026rsquo;s network.\ntraefik: image: ${REGISTRY}/traefik:1.6 build: ./traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - traefik environment: - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} - AWS_REGION=${AWS_REGION} - AWS_HOSTED_ZONE_ID=${AWS_HOSTED_ZONE_ID} ports: - target: 80 published: 80 protocol: tcp mode: host - target: 443 published: 443 mode: host protocol: tcp - target: 8080 published: 8080 mode: host protocol: tcp deploy: mode: global restart_policy: condition: on-failure Docker Swarm deployed to AWS and lives behind internal/external load balancers (Classic type).\n// terraform SG fragment ingress { from_port = 80 to_port = 80 protocol = \u0026#34;tcp\u0026#34; description = \u0026#34;acme chellange\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 443 to_port = 443 protocol = \u0026#34;tcp\u0026#34; description = \u0026#34;SSL termination\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } Let\u0026rsquo;s assume mydomain.com/mobile-api should be worldwide visible but the rest of app should be available via Whitelist. Hopefully Traefik supports entrypoints by route, so there is nothing easiest then make one more clone of app and set frontend rule targeting to /route.\nmodile-api: image: ${REGISTRY}/app:${VERSION:-latest} networks: - traefik deploy: mode: replicated replicas: 1 restart_policy: condition: on-failure labels: - traefik.backend=modile-api - traefik.port=80 - traefik.frontend.rule=Host:${HOST_API};PathPrefix:/mobile-api - traefik.docker.network=traefik - traefik.enable=true app: image: ${REGISTRY}/app:${VERSION:-latest} networks: - traefik deploy: mode: replicated replicas: 1 restart_policy: condition: on-failure labels: - traefik.backend=app - traefik.port=80 - traefik.frontend.whiteList.sourceRange=${WHITE_LIST} - traefik.frontend.whiteList.useXForwardedFor=true - traefik.frontend.rule=Host:${HOST_API} - traefik.docker.network=traefik - traefik.enable=true Important part: set up ProxyProtocol on both side Traefik (reverse-proxy) and AWS ELB. Proxy protocol Traefik side: traefik.toml\n[entryPoints.https.whiteList] sourceRange = [\u0026#34;1.2.3.4/24\u0026#34;] # you can override this part on service level useXForwardedFor = true [entryPoints.https.proxyProtocol] trustedIPs = [\u0026#34;10.0.100.0/24\u0026#34;] # private subnet CIRD block or IPs [entryPoints.https.forwardedHeaders] trustedIPs = [\u0026#34;10.0.100.0/24\u0026#34;] # private subnet CIRD block or IPs Proxy protocol AWS side: (if your listener settings support Proxy Protocol! )\n1 # make sure proxyPolicy is disabled. =\u0026gt; \u0026#34;BackendServerDescriptions\u0026#34; : [] aws elb describe-load-balancer-policy-types 2 aws elb create-load-balancer-policy --load-balancer-name %lb_name% --policy-name %name% --policy-type-name ProxyProtocolPolicyType --policy-attributes AttributeName=ProxyProtocol,AttributeValue=true 3 aws elb set-load-balancer-policies-for-backend-server --load-balancer-name %lb_name% --instance-port 443 --policy-names %policy_name% 4 check (optional) aws elb describe-load-balancers --load-balancer-name %lb_name% debug: aws elb delete-load-balancer-policy --load-balancer-name %lb_name% --policy-name %policy_name% # get ELB IPs aws ec2 describe-network-interfaces --filters Name=description,Values=\u0026#34;ELB elb_name\u0026#34; --query \u0026#39;NetworkInterfaces[*].PrivateIpAddresses[*]\u0026#39; If everything goes as expected you‚Äôll see your IP in X-Forwarded-For header üéâ\nHostname: 6b27211a260c IP: 127.0.0.1 IP: 10.255.1.59 IP: 172.18.0.13 IP: 10.0.2.65 GET / HTTP/1.1 Host: domain.com User-Agent: redacted Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9,ru-RU;q=0.8,ru;q=0.7,uk-UA;q=0.6,uk;q=0.5 Cache-Control: max-age=0 Connection: keep-alive Upgrade-Insecure-Requests: 1 X-Forwarded-For: you_real_ip X-Forwarded-Port: 80 X-Forwarded-Proto: https ","permalink":"https://juliakostrikova.com/posts/cloud/traefik-x-forwarded-for/","summary":"Traefik v1.7 is running within a Docker Swarm, functioning as a global service. Consequently, an instance of Traefik is deployed for each host within our Docker Swarm cluster. It is important to note that the Swarm\u0026rsquo;s routing mesh is not employed in this setup. Instead, the port mode is configured as \u0026ldquo;host,\u0026rdquo; allowing the port to be attached to the host\u0026rsquo;s network.\ntraefik: image: ${REGISTRY}/traefik:1.6 build: ./traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - traefik environment: - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} - AWS_REGION=${AWS_REGION} - AWS_HOSTED_ZONE_ID=${AWS_HOSTED_ZONE_ID} ports: - target: 80 published: 80 protocol: tcp mode: host - target: 443 published: 443 mode: host protocol: tcp - target: 8080 published: 8080 mode: host protocol: tcp deploy: mode: global restart_policy: condition: on-failure Docker Swarm deployed to AWS and lives behind internal/external load balancers (Classic type).","title":"Traefik behind AWS ELB. X-Forwarded-For header"},{"content":"What you will learn today ü¶¶: what is Traefik and why I decisively recommend to use it with Docker Swarm how to show custom error page if Traefik returns 404 (service not found) How I met Traefik üòÅ Traefik is a top modern reverse proxy and load balancer. I started to use it from major version 1. At that moment, I already had Docker Swarm cluster, which I began to prepare for production use, and only one thing in the coherent picture has been left: \u0026ldquo;External Load Balancer\u0026rdquo;. Official docker doc had an example with HaProxy so it was obvious to try it out first. As I remember it took a significant amount of time to get HaProxy works smoothly with Swarm. But I wasn\u0026rsquo;t satisfied with the result:\nstatic config which is needed to re-deploy in case of changes *.cfg not supports variables substitution (out of the box) no native support of Lets\u0026rsquo;s Encrypt The production deadline was getting close, but it was out of my religion to leave such an ugly solution. I was searching the Internet and bumped into Traefik. Integration was surprisingly fast and easy. I thought to myself: \u0026ldquo;That is how modern DevOps should look like\u0026rdquo;. It is been 3 years since I deal with Traefik, and today I wanna tell about one of the most much wished-for feature.\nStep by step setup üêü üêí ü¶ß ‚§¥Ô∏è üë∑üèº error-midl Traefik v2.x comes to us with middlewares and ErrorPage one of them.\nLett\u0026rsquo;s assume:\ntraefik dasboard domain: traefik-board.com your app: my-app.com 0001. Add labels to traefik. Important here traefik.http.routers.traefik.middlewares=maintenance-page@docker. If you try to look for https://service-does-not-exists.com you will get friendly error page.\ntraefik: deploy: labels: - \u0026#34;traefik.enable=true\u0026#34; - \u0026#34;traefik.http.services.traefik.loadbalancer.server.port=8080\u0026#34; - \u0026#34;traefik.http.routers.traefik.rule=Host(`${traefik-board.com}`)\u0026#34; - \u0026#34;traefik.http.routers.traefik.entryPoints=websecure\u0026#34; - \u0026#34;traefik.http.routers.traefik.tls=true\u0026#34; - \u0026#34;traefik.http.routers.traefik.middlewares=maintenance-page@docker\u0026#34; 0010. Create dedicated service for error page. Make sure service would be as highly available as Traefik! I recommend to set deploy mode: global and placement: constraints: - node.role == manager. If you don\u0026rsquo;t, hello boring black page again.\nmaintenance-page: deploy: labels: - \u0026#34;traefik.enable=true\u0026#34; - \u0026#34;traefik.http.services.maintenance-page.loadbalancer.server.port=80\u0026#34; - \u0026#34;traefik.http.routers.maintenance-page.rule=HostRegexp(`{host:.+}`)\u0026#34; - \u0026#34;traefik.http.routers.maintenance-page.priority=1\u0026#34; - \u0026#34;traefik.http.routers.maintenance-page.middlewares=maintenance-page@docker\u0026#34; - \u0026#34;traefik.http.routers.maintenance-page.entrypoints=websecure\u0026#34; - \u0026#34;traefik.http.routers.maintenance-page.tls=true\u0026#34; - \u0026#34;traefik.http.middlewares.maintenance-page.errors.status=400-599\u0026#34; - \u0026#34;traefik.http.middlewares.maintenance-page.errors.service=maintenance-page\u0026#34; - \u0026#34;traefik.http.middlewares.maintenance-page.errors.query=/\u0026#34; These lines are essential. You tell the server to catch all requests and redirect them to maintenance-page service. priority=1 means \u0026ldquo;all-catcher\u0026rdquo; is not alone in the system. There is someone higher who wants to handle requests firstly, for example, \u0026ldquo;all-catcher\u0026rdquo; for http-\u0026gt;https redirect.\ntraefik.http.routers.maintenance-page.priority=1 traefik.http.routers.maintenance-page.rule=HostRegexp(`{host:.+}`) 0011. Add priority=100 to app service.\napp: deploy: labels: - \u0026#34;traefik.enable=true\u0026#34; - \u0026#34;traefik.http.routers.frontend.rule=Host(`${my-app.com}`)\u0026#34; - \u0026#34;traefik.http.services.frontend.loadbalancer.server.port=80\u0026#34; - \u0026#34;traefik.http.routers.frontend.entrypoints=websecure\u0026#34; - \u0026#34;traefik.http.routers.frontend.tls=true\u0026#34; - \u0026#34;traefik.http.routers.frontend.priority=100\u0026#34; Testing ü§πüèΩ‚Äç‚ôÄÔ∏è case 1: app service goes down or updating replicas: 0:1 -\u0026gt; see maitenance page case 2: user searched for https://service-does-not-exists.com -\u0026gt; see maitenance page Further reading üë©üèΩ‚Äçüíª hot thread about this topic on the Containous Community Forum nginx based error pages So, that‚Äôs all for now üòä. üë©‚ÄçüöÄ was happy to share my experience, and I\u0026rsquo;m sure this solution will save a bunch of time for someone. Happy hacking=) ü¶æ\n","permalink":"https://juliakostrikova.com/posts/cloud/traefik-error-page/","summary":"What you will learn today ü¶¶: what is Traefik and why I decisively recommend to use it with Docker Swarm how to show custom error page if Traefik returns 404 (service not found) How I met Traefik üòÅ Traefik is a top modern reverse proxy and load balancer. I started to use it from major version 1. At that moment, I already had Docker Swarm cluster, which I began to prepare for production use, and only one thing in the coherent picture has been left: \u0026ldquo;External Load Balancer\u0026rdquo;.","title":"Custom error page in Traefik v2.x. Finally"},{"content":"Task description on Codesignal\nI‚Äôve spend decent amount of time in order to figure out that I don‚Äôt need any string manipulation in this task üòÖ. My first try was adding missing zeros to the beginning of number slot, convert int to str and back, then the resulting string split by 4 but no luck ‚Ä¶ It turned out that is simple math üòÄ I wanna share my solution with detailed comments ‚¨áÔ∏è (Time complexity O(n) )\n\u0026lt;!-- Python code --\u0026gt; \u0026#39;\u0026#39;\u0026#39; Test cases a = [123, 4, 5] b = [100, 100, 100] a = [9876, 5432, 1999] b = [1, 8001] a = [1] b = [9999, 9999, 9999, 9999, 9999, 9999] \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; helper \u0026#39;\u0026#39;\u0026#39; class ListNode: def __init__(self, x): self.value = x self.next = None \u0026#39;\u0026#39;\u0026#39; helper \u0026#39;\u0026#39;\u0026#39; def array_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) root = head for i in range(1, len(arr)): new = ListNode(arr[i]) head.next = new head = new return root \u0026#39;\u0026#39;\u0026#39; helper \u0026#39;\u0026#39;\u0026#39; def linked_to_array(l): res = [] while l is not None: res.append(l.value) l = l.next return res \u0026#39;\u0026#39;\u0026#39; helper \u0026#39;\u0026#39;\u0026#39; def reverse(l): prev = None head = l while head: next = head.next head.next = prev prev = head head = next return prev def addTwoHugeNumbers(a, b): \u0026#39;\u0026#39;\u0026#39; in order to proceed with addition from right to left we need to reverse linked list and when we finish reverse it back \u0026#39;\u0026#39;\u0026#39; a = reverse(a) b = reverse(b) \u0026#39;\u0026#39;\u0026#39; init resulting linked list and buffer \u0026#39;\u0026#39;\u0026#39; head = None root = None buffer = 0 while a or b: \u0026#39;\u0026#39;\u0026#39; set 0 if NodeList element is already None \u0026#39;\u0026#39;\u0026#39; a_value = 0 if not a else a.value b_value = 0 if not b else b.value sum_els = a_value + b_value if buffer != 0: sum_els = sum_els + buffer buffer = 0 \u0026#39;\u0026#39;\u0026#39; 10000 - condition to move to another number order buffer - always 1 because 9 is the highest value in decimal numeral system \u0026#39;\u0026#39;\u0026#39; if sum_els \u0026gt; 9999: sum_els = sum_els - 10000 buffer = 1 new = ListNode(sum_els) if head is None: head = new root = head else: head.next = new head = new a = None if not a else a.next b = None if not b else b.next \u0026#39;\u0026#39;\u0026#39; if we have not empty buffer at the end of addition then add one more NodeList to the beginning \u0026#39;\u0026#39;\u0026#39; if buffer != 0: new = ListNode(buffer) head.next = new return reverse(root) \u0026#39;\u0026#39;\u0026#39; we are going to do column addition like we do at school but with only difference: addition not one by one but four by four for example: 123, 4, 5 100,100,100 \u0026#39;\u0026#39;\u0026#39; a = array_to_linked_list(a) b = array_to_linked_list(b) result = addTwoHugeNumbers(a, b) print(linked_to_array(result)) ","permalink":"https://juliakostrikova.com/posts/algorithms/addtwohugenumbers/","summary":"Task description on Codesignal\nI‚Äôve spend decent amount of time in order to figure out that I don‚Äôt need any string manipulation in this task üòÖ. My first try was adding missing zeros to the beginning of number slot, convert int to str and back, then the resulting string split by 4 but no luck ‚Ä¶ It turned out that is simple math üòÄ I wanna share my solution with detailed comments ‚¨áÔ∏è (Time complexity O(n) )","title":"Solution for CodeSignal: addTwoHugeNumbers (Linked List part üëØ)"},{"content":"1 Add tools specifically to php monitoring in order to answer the questions ‚¨áÔ∏è what kind of php scripts were called most of the time? what kind of php scripts took the most CPU? We choose open-source tool Pinba.\nphp pinba extension sends data over UDP in protobuf format. pinba server accumulates and processes data and send it to data storage in your choice. (In our case it is Clickhouse DB)\nIt is not a secret that the most popular script in php frameworks is index.php but this information is barely helpful. So we need some ‚ÄúCPU statistics per route‚Äù.\n‚ÄúCPU statistics per route‚Äù means that: we have to implement one more chart in Grafana that shows CPU consumption in the matter of requested route, for example, V2\\Community\\Model.php And only after that we can give this info to developers for investigation what kind of code took the most CPU in the route: V2\\Community\\Model.php When the developer got the list of routes it is time to look inside those routes and investigate what cause high CPU. On this stage Blackfire can help. Blackfire will show you CPU Wall Time. To keep things simple, Wall Time is usually split in two main parts: the CPU Time and the I/O Time.\nThe CPU time is the amount of time the CPU was used for processing instructions. The I/O time is the time the CPU waited for input/output (I/O) operations.\nI/O time could be divided into two parts: the network and the disk.\nNetwork activity includes calls to databases like:\nMySQL, PostgreSQL, or MongoDB; HTTP calls to web services and APIs; Calls to cache systems like Redis and Memcached; Communications with services like queues, email daemons, remote filesystems; etc. Disk activity occurs when a program reads files from the filesystem, including loading code or files.\nWe need to distinguish these types of times in order to make further decisions related optimization.\nA CPU-bound program‚Äôs speed depends mostly on the CPU. In other words, CPU utilization is high for long periods of time. The faster the CPU, the faster the code runs. On the contrary, an I/O bound program‚Äôs speed is determined by the time spent waiting for I/O. Faster disks or a faster network improve the overall performance of I/O bound code.\n2 After that, depending on findings ‚¨áÔ∏è IF the reason of high CPU is I/O bound related to DB (too much time waiting for I/O ) then we should consider migrate to RDS and set up storage General Purpose (SSD) or Provisioned IOPS (SSD).\nIF the reason of high CPU : CPU-bound (which is rare case for web applications) then we should consider to optimize algorithms in code.\nto be continued‚Ä¶ üëÄ\n","permalink":"https://juliakostrikova.com/posts/php/high-cpu/","summary":"1 Add tools specifically to php monitoring in order to answer the questions ‚¨áÔ∏è what kind of php scripts were called most of the time? what kind of php scripts took the most CPU? We choose open-source tool Pinba.\nphp pinba extension sends data over UDP in protobuf format. pinba server accumulates and processes data and send it to data storage in your choice. (In our case it is Clickhouse DB)","title":"How to analyse ‚Äúhigh CPU‚Äù in php on production. Part 1"},{"content":"Into üíÜ Pre-conditions: macOS Sierra Docker CE Version 17.06.2-ce-mac27 PHP 7.1.8 XDebug v2.5.0 PhpStorm 2017.2 If you want to set up remote debug from your container you have 2 options:\nxdebug.remote_host = %host_ip% %host_ip% ‚Äî The IP of the machine running your IDE. It‚Äôs assumed on the same host as Docker. xdebug.remote_connect_back = on checks $_SERVER[‚ÄòHTTP_X_FORWARDED_FOR‚Äô] and $_SERVER[‚ÄòREMOTE_ADDR‚Äô] variables to find out which IP address to use. You cannot use xdebug.remote_connect_back because it takes containers‚Äôs internal IP. So xdebug.remote_host is the only option we have. It‚Äôs pretty simple to get host IP on Linux OS just look at : ifconfig \u0026gt; docker0. Moreover you can create a fixed set of IPs for both host and containers using docker network. For instance:\ndocker network create -d bridge \\ ‚Äî subnet 192.168.0.0/24 \\ ‚Äî gateway 192.168.0.1 \\ dockernet Now each container can connect to the host under the fixed IP 192.168.0.1 But the docker0 interface is not available for Docker in macOS. This interface is actually within HyperKit. So unfortunately there is no a reliable way of looping back to host for macOS. The only solution is to create your local IP‚Äôs alias to something else : sudo ifconfig lo0 alias 10.254.254.254\nHowTo guide üë©‚Äçüíª sudo ifconfig lo0 alias 10.254.254.254 (optional) For permanent setting up save.plist file sudo curl -o /Library/LaunchDaemons/com.yuklia.docker_localhost_alias.plist build docker containers \u0026hellip; add server to IDE storm1 configure Debug‚Äôs port in my case it‚Äôs 9002. xDebug client will knock to this port. storm2 configure DBGp Proxy storm3 Bonus üç∞ If you need to get a shell of the VM that was created by HyperKit run:\nscreen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty or screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty For getting all screens run: screen -ls For exiting screen run : screen -X -S %screen_name% kill Once you get the tty running you can navigate to /var/lib/docker: storm4 Here is my Dockerfile and docker-compose versions for php:7-fpm with XDebug So that‚Äôs all for now üòä. Hope it will save a bunch of time for someone! I will be glad to get comments and questions. Happy hacking=) ü¶æ\n","permalink":"https://juliakostrikova.com/posts/php/xdebug-macos/","summary":"Into üíÜ Pre-conditions: macOS Sierra Docker CE Version 17.06.2-ce-mac27 PHP 7.1.8 XDebug v2.5.0 PhpStorm 2017.2 If you want to set up remote debug from your container you have 2 options:\nxdebug.remote_host = %host_ip% %host_ip% ‚Äî The IP of the machine running your IDE. It‚Äôs assumed on the same host as Docker. xdebug.remote_connect_back = on checks $_SERVER[‚ÄòHTTP_X_FORWARDED_FOR‚Äô] and $_SERVER[‚ÄòREMOTE_ADDR‚Äô] variables to find out which IP address to use. You cannot use xdebug.","title":"XDebug for PHP docker container on macOS"}]